# گزارش تمرین شماره ۱ - طراحی شی‌گرا

**اعضای گروه:**
۱. [امیرمهدی سعیدی]
۲. [محمدسهیل اسلامی]

---

## گام اول: افزودن قابلیت‌ها (Step-01)
طبق خواسته تمرین، دو قابلیت «ارسال پیامک» و «پرداخت حضوری» را به پروژه اضافه کردیم. تغییراتی که برای این کار در کد اعمال شد در جدول زیر آمده است:

| ردیف | کلاس تغییر یافته | توضیح کوتاه تغییر |
| :---: | :--- | :--- |
| **۱** | `Notifier.java` | اضافه کردن گزینه `SMS` به لیست نوتیفایرها |
| **۲** | `SmsSender.java` | **(فایل جدید)** ایجاد کلاس جدید برای ارسال پیامک (مشابه ایمیل) |
| **۳** | `ReservationService.java` | اضافه کردن `case` جدید در سوییچ برای ارسال پیامک |
| **۴** | `PaymentMethods.java` | اضافه کردن گزینه `ON_SITE` به روش‌های پرداخت |
| **۵** | `PaymentProcessor.java` | نوشتن تابع `payOnSite` برای انجام عملیات پرداخت حضوری |
| **۶** | `ReservationService.java` | اضافه کردن `case` جدید در سوییچ برای فراخوانی پرداخت حضوری |

---

## گام دوم: تحلیل اصول شی‌گرایی (بررسی کد اولیه)
در این بخش، کدهای مرحله قبل را بر اساس اصول SOLID و سایر اصول خواسته شده بررسی کردیم. نتایج در جدول زیر مشخص شده است:

| اصل | وضعیت | کلاس مربوطه | علت برقراری / نقض |
| :---: | :---: | :--- | :--- |
| **SRP** | ❌ **نقض** | `ReservationService` | [cite_start]این کلاس چند وظیفه مختلف دارد: هم رزرو را انجام می‌دهد، هم درگیر جزئیات پرداخت شده و هم درگیر نحوه ارسال پیام است. [cite: 34] |
| **OCP** | ❌ **نقض** | `ReservationService`<br>`PaymentProcessor` | [cite_start]برای اضافه کردن قابلیت‌های جدید (پیامک و پرداخت حضوری) مجبور شدیم کدهای این کلاس‌ها را تغییر دهیم، در حالی که باید بدون تغییر کد اصلی، قابلیت اضافه می‌شد. [cite: 34] |
| **LSP** | ✅ **برقراری** | - | [cite_start]چون از وراثت پیچیده‌ای استفاده نشده و کلاسی رفتار پدرش را نقض نکرده، این اصل رعایت شده است. [cite: 35] |
| **ISP** | ✅ **برقراری** | - | [cite_start]اینترفیس بزرگی نداریم که کلاس‌ها مجبور باشند متدهای بی‌استفاده را پیاده‌سازی کنند. [cite: 35] |
| **DIP** | ❌ **نقض** | `ReservationService` | [cite_start]کلاس سطح بالا (`ReservationService`) مستقیماً به کلاس‌های سطح پایین (`EmailSender`, `PaymentProcessor`) وابسته است و آن‌ها را `new` می‌کند. [cite: 36] |
| **PLK** | ✅ **برقراری** | `Main` | [cite_start]قانون دمیتر (Law of Demeter) رعایت شده و زنجیره‌های طولانی فراخوانی متد در کد دیده نمی‌شود. [cite: 36] |
| **CRP** | ✅ **برقراری** | پکیج‌ها | [cite_start]کلاس‌هایی که با هم استفاده می‌شوند در یک پکیج قرار دارند و وابستگی غیرضروری دیده نمی‌شود. [cite: 36] |

---

## گام سوم: اصلاح موارد نقض (Step-2-with-OOD)
برای رفع مشکلات بالا، در پوشه `Step-2` تغییرات زیر را اعمال کردیم:

1.  **استفاده از اینترفیس (Abstraction):**
    * اینترفیس `MessageSender` برای ارسال پیام ساخته شد.
    * اینترفیس `PaymentMethod` برای روش‌های پرداخت ساخته شد.
    * [cite_start]با این کار مشکلات DIP و OCP حل شد چون سرویس اصلی فقط با اینترفیس کار می‌کند. [cite: 38]

2.  **الگوی Strategy:**
    * کلاس‌های پرداخت (`OnSitePayment`, `OnlinePayment`) و پیام‌رسانی (`SmsSender`) جدا شدند.

3.  **تزریق وابستگی (DI):**
    * وابستگی‌ها در `Main` ساخته می‌شوند و به سازنده (Constructor) کلاس `ReservationService` پاس داده می‌شوند.

---

## گام چهارم: ارزیابی
**سوال:** اگر اصول شی‌گرایی از ابتدا رعایت می‌شد، چند تا از تغییرات گام اول حذف می‌شد؟

**پاسخ:**
تقریباً تمام تغییراتی که در فایل‌های قدیمی (`ReservationService`, `PaymentProcessor`) دادیم حذف می‌شدند.
[cite_start]اگر معماری درست بود، ما فقط فایل‌های جدید (`SmsSender.java`, `OnSitePayment.java`) را می‌ساختیم و کد اصلی دست‌نخورده باقی می‌ماند. [cite: 40]

---

## گام پنجم: نتیجه‌گیری
رعایت اصول شی‌گرایی باعث می‌شود کد در برابر تغییرات مقاوم باشد. [cite_start]وقتی OCP رعایت شود، اضافه کردن قابلیت جدید (مثل یک روش پرداخت دیگر) باعث ایجاد باگ در کدهای قبلی نمی‌شود و تست کردن برنامه هم راحت‌تر خواهد بود. [cite: 43]
