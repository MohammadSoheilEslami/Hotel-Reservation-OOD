# گزارش تمرین شماره ۱ - طراحی شی‌گرا

**اعضای گروه:**
۱. [امیرمهدی سعیدی]
۲. [محمدسهیل اسلامی]

---

## گام اول: افزودن قابلیت‌ها (Step-01)
در این مرحله طبق خواسته تمرین، دو قابلیت «ارسال پیامک» و «پرداخت حضوری» را سریع و بدون تغییر معماری به کد اضافه کردیم. جزئیات تغییرات در جدول زیر آمده است:

| ردیف | کلاس تغییر یافته | توضیح کوتاه تغییر |
| :---: | :--- | :--- |
| **۱** | `Notifier.java` | اضافه کردن گزینه `SMS` به لیست نوتیفایرها |
| **۲** | `SmsSender.java` | **(فایل جدید)** ایجاد کلاس جدید برای ارسال پیامک (مشابه کلاس ایمیل) |
| **۳** | `ReservationService.java` | اضافه کردن `case` جدید در دستور `switch` برای مدیریت ارسال پیامک |
| **۴** | `PaymentMethods.java` | اضافه کردن گزینه `ON_SITE` به لیست روش‌های پرداخت |
| **۵** | `PaymentProcessor.java` | نوشتن متد جدید `payOnSite` برای انجام عملیات پرداخت حضوری |
| **۶** | `ReservationService.java` | اضافه کردن `case` جدید در دستور `switch` برای فراخوانی متد پرداخت حضوری |

---

## گام دوم: تحلیل اصول شی‌گرایی (بررسی کد اولیه)
طبق جدول خواسته شده در صورت تمرین، وضعیت رعایت یا نقض اصول شی‌گرایی را در کد اولیه (قبل از اصلاحات) بررسی کردیم:

| اصل | وضعیت | کلاس مربوطه | علت برقراری / نقض |
| :---: | :---: | :--- | :--- |
| **SRP**<br>(تک وظیفه‌ای) | ❌ **نقض** | `ReservationService` | این کلاس تمرکز واحد ندارد؛ هم مسئولیت رزرو را دارد، هم درگیر جزئیات نحوه پرداخت شده و هم درگیر انتخاب روش ارسال پیام است. |
| **OCP**<br>(باز-بسته) | ❌ **نقض** | `ReservationService`<br>`PaymentProcessor` | این اصل به شدت نقض شده است. برای افزودن قابلیت‌های جدید (پیامک و پرداخت حضوری) مجبور شدیم فایل‌های کلاس‌های اصلی را باز کنیم و تغییر دهیم. |
| **LSP**<br>(جایگزینی لیسکوف) | ✅ **برقراری** | - | چون در کد اولیه سلسله مراتب وراثت پیچیده‌ای نداشتیم و کلاسی رفتار کلاس پدرش را خراب نکرده بود، این اصل رعایت شده است. |
| **ISP**<br>(تفکیک رابط‌ها) | ✅ **برقراری** | - | اینترفیس بزرگی در برنامه وجود نداشت که کلاس‌ها مجبور به پیاده‌سازی متدهای بلااستفاده باشند (در واقع اصلاً اینترفیسی نبود). |
| **DIP**<br>(وارونگی وابستگی) | ❌ **نقض** | `ReservationService` | کلاس سطح بالا (`ReservationService`) مستقیماً به کلاس‌های سطح پایین (`EmailSender` و `PaymentProcessor`) وابسته است و آن‌ها را `new` می‌کند، به جای اینکه به یک Abstract وابسته باشد. |
| **PLK**<br>(قانون دمیتر) | ✅ **برقراری** | `Main` | قانون «کمترین دانش» تا حد خوبی رعایت شده است. در کد زنجیره‌های طولانی فراخوانی متد (مثل `a.getB().getC().do()`) که نشان‌دهنده وابستگی زیاد باشد، دیده نمی‌شود. |
| **CRP**<br>(استفاده مشترک) | ✅ **برقراری** | پکیج‌ها | کلاس‌هایی که با هم استفاده می‌شوند (مثل مدل‌ها در `models` و سرویس‌ها در `services`) در پکیج‌های مناسب دسته‌بندی شده‌اند. |

---

## گام سوم: اصلاح موارد نقض (Step-2-with-OOD)
برای رفع مشکلات تحلیل شده در مرحله قبل، در پوشه `Step-2` تغییرات زیر را اعمال کردیم:

1.  **رفع مشکل وابستگی (DIP):**
    * اینترفیس `MessageSender` را ساختیم تا سرویس به جای کلاس `EmailSender`، به این اینترفیس وابسته باشد.
    * اینترفیس `PaymentMethod` را ساختیم تا سرویس به جای `PaymentProcessor`، با این اینترفیس کار کند.

2.  **رفع مشکل توسعه‌پذیری (OCP):**
    * از الگوی **Strategy** استفاده کردیم. حالا هر روش پرداخت (`OnSitePayment`, `OnlinePayment`) و هر روش پیام‌رسانی (`SmsSender`) یک کلاس جداگانه است.
    * برای اضافه کردن روش جدید، دیگر نیازی به تغییر `ReservationService` و شرط‌های `switch` نیست.

3.  **تزریق وابستگی (DI):**
    * وابستگی‌ها در داخل کلاس `ReservationService` ساخته نمی‌شوند (`new` نمی‌شوند)، بلکه از بیرون (در فایل `Main`) ساخته شده و به سازنده کلاس پاس داده می‌شوند.

---

## گام چهارم: ارزیابی
**سوال:** اگر اصول شی‌گرایی از ابتدا رعایت می‌شد، چند تا از تغییرات گام اول حذف می‌شد؟

**پاسخ:**
تقریباً تمام تغییراتی که در فایل‌های قدیمی و اصلی (`ReservationService` و `PaymentProcessor`) اعمال کردیم حذف می‌شدند.
اگر معماری از ابتدا درست بود، برای اضافه کردن پیامک و پرداخت حضوری، ما **فقط فایل‌های جدید** (`SmsSender.java`, `OnSitePayment.java`) را می‌ساختیم و هیچ خط کدی از هسته منطقی سیستم تغییر نمی‌کرد.

---

## گام پنجم: نتیجه‌گیری
رعایت اصول شی‌گرایی (مخصوصاً SOLID) هزینه تغییرات را در آینده به شدت کاهش می‌دهد. وقتی کد OCP باشد، اضافه کردن فیچر جدید ریسک خراب کردن کدهای قبلی را ندارد. همچنین رعایت DIP باعث می‌شود ماژول‌ها مستقل شوند و نوشتن تست برای آن‌ها راحت‌تر باشد.
